 

// Test enum with multiple payload types
enum Result {
    Ok(int),
    Err(string),
}

// Test enum with multiple payload values
enum Point {
    Cartesian(int, int),
    Polar(float, float),
}

// Test nested enum pattern
enum Option {
    Some(int),
    None,
}

enum NestedResult {
    Success(Option),
    Failure(string),
}

fn main() {
    // Test 1: Multiple payload values extraction
    let p1 = Point::Cartesian(10, 20);
    match p1 {
        Point::Cartesian(x, y) => {
            println("Cartesian coordinates:");
            println(x);
            println(y);
        },
        Point::Polar(r, theta) => {
            println("Polar coordinates:");
            println(r);
            println(theta);
        },
    };

    // Test 2: Different payload types
    let r1 = Result::Ok(42);
    let r2 = Result::Err("error message");
    
    match r1 {
        Result::Ok(value) => {
            println("Ok value:");
            println(value);
        },
        Result::Err(msg) => {
            println("Error:");
            println(msg);
        },
    };

    match r2 {
        Result::Ok(value) => {
            println("Ok value:");
            println(value);
        },
        Result::Err(msg) => {
            println("Error message:");
            println(msg);
        },
    };

    // Test 3: Nested enum pattern matching
    let nested1 = NestedResult::Success(Option::Some(100));
    let nested2 = NestedResult::Success(Option::None);
    let nested3 = NestedResult::Failure("nested error");

    match nested1 {
        NestedResult::Success(Option::Some(val)) => {
            println("Nested Success with Some:");
            println(val);
        },
        NestedResult::Success(Option::None) => {
            println("Nested Success with None");
        },
        NestedResult::Failure(msg) => {
            println("Nested Failure:");
            println(msg);
        },
    };

    match nested2 {
        NestedResult::Success(Option::Some(val)) => {
            println("Nested Success with Some:");
            println(val);
        },
        NestedResult::Success(Option::None) => {
            println("Nested Success with None");
        },
        NestedResult::Failure(msg) => {
            println("Nested Failure:");
            println(msg);
        },
    };

    match nested3 {
        NestedResult::Success(Option::Some(val)) => {
            println("Nested Success with Some:");
            println(val);
        },
        NestedResult::Success(Option::None) => {
            println("Nested Success with None");
        },
        NestedResult::Failure(msg) => {
            println("Nested Failure:");
            println(msg);
        },
    };

    // Test 4: Match expression returning values
    let result = match r1 {
        Result::Ok(v) => v * 2,
        Result::Err(_) => 0,
    };
    println("Doubled result:");
    println(result);
}

