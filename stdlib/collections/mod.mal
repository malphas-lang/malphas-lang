// Collections module
// Note: Vec and HashMap are in separate files (vec.mal, hashmap.mal) for organization
// but currently need to be in mod.mal until pub use is supported

// ============================================================================
// Vec - Dynamic array implementation
// ============================================================================

pub struct Vec[T] {
    data: []T,
}

impl[T] Vec[T] {
    pub fn new() -> Vec[T] {
        return Vec[T] {
            data: []T{}
        };
    }

    pub fn push(&mut self, item: T) -> void {
        self.data = append(self.data, item);
    }

    pub fn get(&self, index: int) -> T {
        return self.data[index];
    }

    pub fn set(&mut self, index: int, value: T) -> void {
        self.data[index] = value;
    }

    pub fn len(&self) -> int {
        // Note: len(self.data) should be handled by the builtin len() function
        // which should map to runtime_slice_len for slices
        // The codegen will extract self.data and call the runtime function
        return len(self.data);
    }

    pub fn is_empty(&self) -> bool {
        return self.len() == 0;
    }

    pub fn pop(&mut self) -> T? {
        if self.len() == 0 {
            return nil;
        }
        let item = self.data[-1];
        delete(self.data, -1);
        return item;
    }
}

// ============================================================================
// HashMap - Hash table implementation
// ============================================================================

pub struct HashMap[K, V] {
    data: map[K, V],
}

impl[K, V] HashMap[K, V] {
    pub fn new() -> HashMap[K, V] {
        return HashMap[K, V] {
            data: map[K, V]{}
        };
    }

    pub fn put(&mut self, key: K, value: V) -> void {
        self.data[key] = value;
    }

    pub fn get(&self, key: K) -> V? {
        return self.data[key];
    }

    pub fn remove(&mut self, key: K) -> V? {
        let val = self.data[key];
        delete(self.data, key);
        return val;
    }

    pub fn len(&self) -> int {
        // Note: len(self.data) should be handled by the builtin len() function
        // which should map to runtime_hashmap_len for maps
        // The codegen will extract self.data and call the runtime function
        return len(self.data);
    }

    pub fn is_empty(&self) -> bool {
        return self.len() == 0;
    }

    pub fn clear(&mut self) -> void {
        self.data = map[K, V]{};
    }

    pub fn contains_key(&self, key: K) -> bool {
        // Check if key exists in the map
        // The codegen will map this method call to runtime_hashmap_contains_key
        // which checks if the key exists and returns 1 (true) or 0 (false)
        // Since map[key] returns V?, we can check if it's not nil
        let result = self.data[key];
        return result != nil;
    }
}
