
// Generic Result type
enum Result[T, E] {
    Ok(T),
    Err(E)
}

// Generic Character struct
struct Character[S] {
    name: string,
    stats: S
}

// Concrete stats for our RPG
struct RpgStats {
    hp: int,
    max_hp: int,
    attack: int,
    defense: int
}

enum Action {
    Attack,
    Heal,
    Defend
}

fn modulo(a: int, b: int) -> int {
    return a - (b * (a / b));
}

fn rand(seed: int) -> int {
    let mut new_seed = (seed * 1103515245 + 12345);
    new_seed = modulo(new_seed, 2147483647);
    if new_seed < 0 {
        new_seed = -new_seed;
    }
    return new_seed;
}

fn rand_range(seed: int, min: int, max: int) -> int {
    let r = rand(seed);
    return min + modulo(r, (max - min + 1));
}

// Battle function using generic Character with RpgStats
// Note: We specify Character[RpgStats] here because we need to access specific fields
// In a more advanced version with traits, we could use Character[S: StatsTrait]
// Helper functions removed as explicit instantiation is now supported

fn battle(hero: Character[RpgStats], monster: Character[RpgStats], seed: int) -> Result[int, string] {
    let mut round = 0;
    let mut current_seed = seed;
    
    println("Battle Start!");
    println(hero.name);
    println("vs");
    println(monster.name);
    
    while hero.stats.hp > 0 {
        if monster.stats.hp <= 0 {
            return Result[int, string]::Ok(round);
        }
        
        round = round + 1;
        println("Round:");
        println(round);
        
        // Hero's turn
        let mut action = Action::Attack;
        if hero.stats.hp < (hero.stats.max_hp / 3) {
            action = Action::Heal;
        }
        
        match action {
            Action::Attack => {
                let damage = hero.stats.attack - (monster.stats.defense / 2);
                if damage < 1 { damage = 1; }
                monster.stats.hp = monster.stats.hp - damage;
                println(hero.name);
                println("attacks for damage:");
                println(damage);
            },
            Action::Heal => {
                let heal = hero.stats.max_hp / 4;
                hero.stats.hp = hero.stats.hp + heal;
                if hero.stats.hp > hero.stats.max_hp { hero.stats.hp = hero.stats.max_hp; }
                println(hero.name);
                println("heals HP:");
                println(heal);
            },
            Action::Defend => {
                println(hero.name);
                println("defends!");
            }
        };
        
        if monster.stats.hp <= 0 {
            continue;
        }
        
        // Monster's turn
        current_seed = rand(current_seed);
        let roll = rand_range(current_seed, 0, 2);
        
        let mut monster_action = Action::Attack;
        if roll == 1 {
            monster_action = Action::Defend;
        } else if roll == 2 {
             monster_action = Action::Heal;
        }
        
        match monster_action {
            Action::Attack => {
                let damage = monster.stats.attack - (hero.stats.defense / 2);
                if damage < 1 { damage = 1; }
                hero.stats.hp = hero.stats.hp - damage;
                println(monster.name);
                println("attacks for damage:");
                println(damage);
            },
            Action::Heal => {
                let heal = monster.stats.max_hp / 5;
                monster.stats.hp = monster.stats.hp + heal;
                if monster.stats.hp > monster.stats.max_hp { monster.stats.hp = monster.stats.max_hp; }
                println(monster.name);
                println("heals HP:");
                println(heal);
            },
            Action::Defend => {
                println(monster.name);
                println("defends!");
            }
        };
        
        println("Hero HP:");
        println(hero.stats.hp);
        println("Monster HP:");
        println(monster.stats.hp);
    }
    
    return Result[int, string]::Err("Defeat...");
}

fn main() {
    let hero_stats = RpgStats {
        hp: 100,
        max_hp: 100,
        attack: 20,
        defense: 10
    };
    
    let hero = Character {
        name: "Hero",
        stats: hero_stats
    };
    
    let monster_stats = RpgStats {
        hp: 150,
        max_hp: 150,
        attack: 25,
        defense: 5
    };
    
    let monster = Character {
        name: "Dragon",
        stats: monster_stats
    };
    
    let seed = 12345;
    let result = battle(hero, monster, seed);
    
    match result {
        Result::Ok(rounds) => {
            println("Victory in rounds:");
            println(rounds);
        },
        Result::Err(msg) => {
            println(msg);
        }
    };
}
