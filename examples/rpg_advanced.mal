// Advanced RPG Simulation using Generics and Methods
mod core;
use core::Slice;

enum Option[T] {
    Some(T),
    None
}

enum Result[T, E] {
    Ok(T),
    Err(E)
}

struct Item {
    name: string,
    power: int
}

// Generic Inventory struct
struct Inventory[T] {
    item: T // Simplified to single item
}

// Methods for generic Inventory
impl[T] Inventory[T] {
    fn get_item(self) -> T {
        return self.item;
    }
    
    fn set_item(self, item: T) {
        self.item = item;
    }
}

struct Character {
    name: string,
    inventory: Inventory[Item]
}

impl Character {
    fn get_name(self) -> string {
        return self.name;
    }
}

fn main() {
    println("Advanced RPG Generics");
    
    let sword = Item { name: "Excalibur", power: 100 };
    let inv = Inventory[Item] { item: sword };
    
    let mut hero = Character { name: "Arthur", inventory: inv };
    
    println("Hero:");
    println(hero.get_name());
    
    let item = hero.inventory.get_item();
    println("Item:");
    println(item.name);
    println("Power:");
    println(item.power);
    
    // Test nested generics
    println("Nested Generics Test:");
    let opt = Option[int]::Some(42);
    let res = Result[Option[int], string]::Ok(opt);
    
    match res {
        Result::Ok(val) => {
            match val {
                Option::Some(x) => {
                    println("Got Some:");
                    println(x);
                },
                Option::None => {
                    println("Got None");
                }
            }
        },
        Result::Err(e) => {
            println("Error:");
            println(e);
        }
    };
    
    // Test Slice[T] methods
    println("Testing Slice methods:");
    
    let mut items: Slice[Item] = Slice[Item]::new();
    
    // Test push
    items.push(Item { name: "Sword", power: 50 });
    items.push(Item { name: "Shield", power: 30 });
    items.push(Item { name: "Potion", power: 20 });
    
    println("Inventory items:");
    println(items.len());
    
    // Test is_empty
    if !items.is_empty() {
        println("Inventory is not empty");
    }
    
    // Test get
    let first_item = items.get(0 as usize);
    println("First item:");
    println(first_item.name);
    println(first_item.power);
    
    // Test capacity
    println("Capacity:");
    println(items.cap());
}
