package llvm

import (
	"fmt"
	"strconv"
	"strings"

	mast "github.com/malphas-lang/malphas-lang/internal/ast"
	"github.com/malphas-lang/malphas-lang/internal/diag"
	"github.com/malphas-lang/malphas-lang/internal/types"
)

// genFieldExpr generates code for a field access.
func (g *LLVMGenerator) genFieldExpr(expr *mast.FieldExpr) (string, error) {
	// Generate target expression (the struct)
	targetReg, err := g.genExpr(expr.Target)
	if err != nil {
		return "", err
	}

	// Get target type
	var targetType types.Type
	if t, ok := g.typeInfo[expr.Target]; ok {
		targetType = t
	} else {
		g.reportErrorAtNode(
			"cannot determine type of field access target",
			expr,
			diag.CodeGenTypeMappingError,
			"ensure the target expression has a valid type",
		)
		return "", fmt.Errorf("cannot determine type of field access target")
	}

	// Debug: log the target type for troubleshooting (commented out to avoid import)
	// if os.Getenv("MALPHAS_DEBUG_TYPES") != "" {
	// 	fmt.Fprintf(os.Stderr, "DEBUG: field access target type: %T, value: %+v\n", targetType, targetType)
	// }

	// Get field name
	fieldName := expr.Field.Name

	// Check if this is tuple indexing (field name is a number)
	if _, err := strconv.Atoi(fieldName); err == nil {
		// It's a number, so it's tuple indexing: t.0 -> t.F0
		fieldName = fmt.Sprintf("F%s", fieldName)
	}

	// Get the actual struct type from the type system first
	var structName string
	var fieldIndex int
	var found bool
	var actualStruct *types.Struct
	switch t := targetType.(type) {
	case *types.Reference:
		if structType, ok := t.Elem.(*types.Struct); ok {
			actualStruct = structType
		} else if named, ok := t.Elem.(*types.Named); ok && named.Ref != nil {
			if st, ok := named.Ref.(*types.Struct); ok {
				actualStruct = st
			}
		}
	case *types.Pointer:
		if structType, ok := t.Elem.(*types.Struct); ok {
			actualStruct = structType
		} else if named, ok := t.Elem.(*types.Named); ok && named.Ref != nil {
			if st, ok := named.Ref.(*types.Struct); ok {
				actualStruct = st
			}
		}
	case *types.Struct:
		actualStruct = t
	case *types.Named:
		if t.Ref != nil {
			if st, ok := t.Ref.(*types.Struct); ok {
				actualStruct = st
			}
		}
	case *types.GenericInstance:
		if structType, ok := t.Base.(*types.Struct); ok {
			actualStruct = structType
		} else if named, ok := t.Base.(*types.Named); ok && named.Ref != nil {
			if st, ok := named.Ref.(*types.Struct); ok {
				actualStruct = st
			}
		}
	case *types.Tuple:
		// Tuple field access - use numeric index
		if idx, err := strconv.Atoi(expr.Field.Name); err == nil && idx < len(t.Elements) {
			fieldIndex = idx
			found = true
			structName = "" // Tuples don't have a struct name
		}
	}
	
	// If we found a struct, get the field index directly from it
	if actualStruct != nil {
		structName = actualStruct.Name
		fieldIndex = actualStruct.FieldIndex(fieldName)
		if fieldIndex >= 0 {
			found = true
		}
	}
	
	// Fallback to helper function if we didn't find it yet (for cases where we can't get the struct type directly)
	if !found && actualStruct == nil {
		structName, fieldIndex, found = g.findStructFieldIndex(targetType, fieldName)
	}

	// Report error if field not found
	if !found {
		// Try to extract struct name for error message
		if structName == "" {
			if named, ok := targetType.(*types.Named); ok {
				structName = named.Name
			} else {
				structName = fmt.Sprintf("%T", targetType)
			}
		}
		// Try to find similar field names
		var suggestion string
		if structName == "" {
			// structName is still empty, which means we couldn't determine the struct type
			structName = fmt.Sprintf("%T", targetType)
			suggestion = fmt.Sprintf("cannot access field `%s` on type `%T` (struct name could not be determined)", fieldName, targetType)
		} else if fieldMap, ok := g.structFields[structName]; ok {
			var similarFields []string
			for fname := range fieldMap {
				if len(fname) > 0 && len(fieldName) > 0 && fname[0] == fieldName[0] {
					similarFields = append(similarFields, fname)
				}
			}
			if len(similarFields) > 0 {
				suggestion = fmt.Sprintf("did you mean `%s`?", similarFields[0])
			} else {
				suggestion = fmt.Sprintf("check that the field name is correct for struct `%s`", structName)
			}
		} else {
			suggestion = fmt.Sprintf("field `%s` does not exist in struct `%s` (struct not found in generator)", fieldName, structName)
		}

		g.reportErrorAtNode(
			fmt.Sprintf("field `%s` not found in struct `%s`", fieldName, structName),
			expr,
			diag.CodeGenFieldNotFound,
			suggestion,
		)
		return "", fmt.Errorf("field %s not found in struct %s (target type: %T)", fieldName, structName, targetType)
	}

		// Recursively handle the element type
		switch et := elemType.(type) {
		case *types.Struct:
			structName = et.Name
			if fieldMap, ok := g.structFields[structName]; ok {
				if idx, ok := fieldMap[fieldName]; ok {
					fieldIndex = idx
					found = true
				}
			}
		case *types.Named:
			// Check if Ref is set and points to a Struct
			if et.Ref != nil {
				if structType, ok := et.Ref.(*types.Struct); ok {
					structName = structType.Name
					if fieldMap, ok := g.structFields[structName]; ok {
						if idx, ok := fieldMap[fieldName]; ok {
							fieldIndex = idx
							found = true
						}
					}
				} else {
					structName = et.Name
					if fieldMap, ok := g.structFields[structName]; ok {
						if idx, ok := fieldMap[fieldName]; ok {
							fieldIndex = idx
							found = true
						}
					}
				}
			} else {
				structName = et.Name
				if fieldMap, ok := g.structFields[structName]; ok {
					if idx, ok := fieldMap[fieldName]; ok {
						fieldIndex = idx
						found = true
					}
				}
			}
		case *types.GenericInstance:
			if structType, ok := et.Base.(*types.Struct); ok {
				structName = structType.Name
				if fieldMap, ok := g.structFields[structName]; ok {
					if idx, ok := fieldMap[fieldName]; ok {
						fieldIndex = idx
						found = true
					}
				}
			} else if named, ok := et.Base.(*types.Named); ok {
				structName = named.Name
				if fieldMap, ok := g.structFields[structName]; ok {
					if idx, ok := fieldMap[fieldName]; ok {
						fieldIndex = idx
						found = true
					}
				}
			}
		default:
			// Unknown element type - try to extract name for error message
			if named, ok := elemType.(*types.Named); ok {
				structName = named.Name
			} else {
				structName = fmt.Sprintf("%T", elemType)
			}
		}
	case *types.Pointer:
		// Dereference pointer to get element type
		elemType := t.Elem
		// Recursively handle the element type
		switch et := elemType.(type) {
		case *types.Struct:
			structName = et.Name
			if fieldMap, ok := g.structFields[structName]; ok {
				if idx, ok := fieldMap[fieldName]; ok {
					fieldIndex = idx
					found = true
				}
			}
		case *types.Named:
			// Check if Ref is set and points to a Struct
			if et.Ref != nil {
				if structType, ok := et.Ref.(*types.Struct); ok {
					structName = structType.Name
					if fieldMap, ok := g.structFields[structName]; ok {
						if idx, ok := fieldMap[fieldName]; ok {
							fieldIndex = idx
							found = true
						}
					}
				} else {
					structName = et.Name
					if fieldMap, ok := g.structFields[structName]; ok {
						if idx, ok := fieldMap[fieldName]; ok {
							fieldIndex = idx
							found = true
						}
					}
				}
			} else {
				structName = et.Name
				if fieldMap, ok := g.structFields[structName]; ok {
					if idx, ok := fieldMap[fieldName]; ok {
						fieldIndex = idx
						found = true
					}
				}
			}
		case *types.GenericInstance:
			if structType, ok := et.Base.(*types.Struct); ok {
				structName = structType.Name
				if fieldMap, ok := g.structFields[structName]; ok {
					if idx, ok := fieldMap[fieldName]; ok {
						fieldIndex = idx
						found = true
					}
				}
			} else if named, ok := et.Base.(*types.Named); ok {
				structName = named.Name
				if fieldMap, ok := g.structFields[structName]; ok {
					if idx, ok := fieldMap[fieldName]; ok {
						fieldIndex = idx
						found = true
					}
				}
			}
		default:
			// Unknown element type - try to extract name for error message
			if named, ok := elemType.(*types.Named); ok {
				structName = named.Name
			} else {
				structName = fmt.Sprintf("%T", elemType)
			}
		}
	case *types.Struct:
		structName = t.Name
		if fieldMap, ok := g.structFields[structName]; ok {
			if idx, ok := fieldMap[fieldName]; ok {
				fieldIndex = idx
				found = true
			}
		}
	case *types.GenericInstance:
		// For generic instances, get the base struct
		if structType, ok := t.Base.(*types.Struct); ok {
			structName = structType.Name
			if fieldMap, ok := g.structFields[structName]; ok {
				if idx, ok := fieldMap[fieldName]; ok {
					fieldIndex = idx
					found = true
				}
			}
		} else if named, ok := t.Base.(*types.Named); ok {
			structName = named.Name
			if fieldMap, ok := g.structFields[structName]; ok {
				if idx, ok := fieldMap[fieldName]; ok {
					fieldIndex = idx
					found = true
				}
			}
		}
	case *types.Named:
		// Check if Ref is set and points to a Struct
		if t.Ref != nil {
			if structType, ok := t.Ref.(*types.Struct); ok {
				structName = structType.Name
				if fieldMap, ok := g.structFields[structName]; ok {
					if idx, ok := fieldMap[fieldName]; ok {
						fieldIndex = idx
						found = true
					}
				}
			} else {
				// Ref is set but not a Struct, try using the name directly
				structName = t.Name
				if fieldMap, ok := g.structFields[structName]; ok {
					if idx, ok := fieldMap[fieldName]; ok {
						fieldIndex = idx
						found = true
					}
				}
			}
		} else {
			// Ref is nil, use the name directly
			structName = t.Name
			if fieldMap, ok := g.structFields[structName]; ok {
				if idx, ok := fieldMap[fieldName]; ok {
					fieldIndex = idx
					found = true
				}
			}
		}
	case *types.Tuple:
		// Tuple field access - use numeric index
		if idx, err := strconv.Atoi(expr.Field.Name); err == nil && idx < len(t.Elements) {
			fieldIndex = idx
			found = true
		}
		default:
			// Unknown type - try to extract name for error message
			if named, ok := targetType.(*types.Named); ok {
				structName = named.Name
			} else {
				structName = fmt.Sprintf("%T", targetType)
			}
		}
	}

	if !found {
		// Try to find similar field names
		var suggestion string
		if structName == "" {
			// structName is empty, which means we couldn't determine the struct type
			structName = fmt.Sprintf("%T", targetType)
			suggestion = fmt.Sprintf("cannot access field `%s` on type `%T` (struct name could not be determined)", fieldName, targetType)
		} else if fieldMap, ok := g.structFields[structName]; ok {
			var similarFields []string
			for fname := range fieldMap {
				if len(fname) > 0 && len(fieldName) > 0 && fname[0] == fieldName[0] {
					similarFields = append(similarFields, fname)
				}
			}
			if len(similarFields) > 0 {
				suggestion = fmt.Sprintf("did you mean `%s`?", similarFields[0])
			} else {
				suggestion = fmt.Sprintf("check that the field name is correct for struct `%s`", structName)
			}
		} else {
			suggestion = fmt.Sprintf("field `%s` does not exist in struct `%s` (struct not found in generator)", fieldName, structName)
		}

		g.reportErrorAtNode(
			fmt.Sprintf("field `%s` not found in struct `%s`", fieldName, structName),
			expr,
			diag.CodeGenFieldNotFound,
			suggestion,
		)
		return "", fmt.Errorf("field %s not found in struct %s (target type: %T)", fieldName, structName, targetType)
	}

	// Get field type for return value
	// First try to get it from the underlying struct type
	var fieldType types.Type
	var subst map[string]types.Type
	underlyingStruct := g.getUnderlyingStructType(targetType)
	if underlyingStruct != nil && fieldIndex < len(underlyingStruct.Fields) {
		// We have a real struct with fields
		fieldType = underlyingStruct.Fields[fieldIndex].Type
		// Handle generic instances
		if genInst, ok := targetType.(*types.GenericInstance); ok {
			// Build substitution map for type parameters
			subst = make(map[string]types.Type)
			for i, tp := range underlyingStruct.TypeParams {
				if i < len(genInst.Args) {
					subst[tp.Name] = genInst.Args[i]
				}
			}
		}
	} else if structName != "" {
		// Placeholder struct or struct not found - try to get field type from type system
		// Look up the actual struct type from targetType
		var actualStruct *types.Struct
		switch t := targetType.(type) {
		case *types.Reference:
			if structType, ok := t.Elem.(*types.Struct); ok {
				actualStruct = structType
			} else if named, ok := t.Elem.(*types.Named); ok && named.Ref != nil {
				if st, ok := named.Ref.(*types.Struct); ok {
					actualStruct = st
				}
			}
		case *types.Pointer:
			if structType, ok := t.Elem.(*types.Struct); ok {
				actualStruct = structType
			} else if named, ok := t.Elem.(*types.Named); ok && named.Ref != nil {
				if st, ok := named.Ref.(*types.Struct); ok {
					actualStruct = st
				}
			}
		case *types.Struct:
			actualStruct = t
		case *types.Named:
			if t.Ref != nil {
				if st, ok := t.Ref.(*types.Struct); ok {
					actualStruct = st
				}
			}
		case *types.GenericInstance:
			if structType, ok := t.Base.(*types.Struct); ok {
				actualStruct = structType
			} else if named, ok := t.Base.(*types.Named); ok && named.Ref != nil {
				if st, ok := named.Ref.(*types.Struct); ok {
					actualStruct = st
				}
			}
		}
		if actualStruct != nil && fieldIndex < len(actualStruct.Fields) {
			fieldType = actualStruct.Fields[fieldIndex].Type
			// Handle generic instances
			if genInst, ok := targetType.(*types.GenericInstance); ok {
				subst = make(map[string]types.Type)
				for i, tp := range actualStruct.TypeParams {
					if i < len(genInst.Args) {
						subst[tp.Name] = genInst.Args[i]
					}
				}
			}
		}
	}
	// Fallback to original logic for tuples
	if fieldType == nil {
		switch t := targetType.(type) {
		case *types.Tuple:
			if fieldIndex < len(t.Elements) {
				fieldType = t.Elements[fieldIndex]
			}
		}
	}

	if fieldType == nil {
		fieldType = &types.Primitive{Kind: types.Int} // Default
	} else if len(subst) > 0 {
		// Substitute type parameters if we have a GenericInstance
		fieldType = types.Substitute(fieldType, subst)
	}

	fieldLLVM, err := g.mapType(fieldType)
	if err != nil {
		g.reportErrorAtNode(
			fmt.Sprintf("failed to map field type: %v", err),
			expr,
			diag.CodeGenTypeMappingError,
			fmt.Sprintf("the field `%s` has a type that cannot be mapped to LLVM IR", fieldName),
		)
		return "", err
	}

	// Get struct type name for getelementptr
	var structLLVM string
	if tuple, ok := targetType.(*types.Tuple); ok {
		// For tuples, we need to construct the struct type
		// Tuples are represented as anonymous structs
		var elemTypes []string
		for i, elem := range tuple.Elements {
			elemLLVM, err := g.mapType(elem)
			if err != nil {
				g.reportErrorAtNode(
					fmt.Sprintf("failed to map tuple element type at index %d: %v", i, err),
					expr,
					diag.CodeGenTypeMappingError,
					fmt.Sprintf("tuple element at index %d has a type that cannot be mapped to LLVM IR", i),
				)
				return "", fmt.Errorf("failed to map tuple element type: %w", err)
			}
			elemTypes = append(elemTypes, elemLLVM)
		}
		structLLVM = "{" + joinTypes(elemTypes, ", ") + "}*"
	} else {
		structLLVM = "%struct." + sanitizeName(structName) + "*"
	}

	// Use getelementptr to get field pointer
	// getelementptr inbounds %struct.Type, %struct.Type* %ptr, i32 0, i32 fieldIndex
	fieldPtrReg := g.nextReg()
	g.emit(fmt.Sprintf("  %s = getelementptr inbounds %s, %s %s, i32 0, i32 %d",
		fieldPtrReg, strings.TrimSuffix(structLLVM, "*"), structLLVM, targetReg, fieldIndex))

	// Load field value
	resultReg := g.nextReg()
	g.emit(fmt.Sprintf("  %s = load %s, %s* %s", resultReg, fieldLLVM, fieldLLVM, fieldPtrReg))

	return resultReg, nil
}

// genIndexExpr generates code for an index expression.
func (g *LLVMGenerator) genIndexExpr(expr *mast.IndexExpr) (string, error) {
	// Generate target expression
	targetReg, err := g.genExpr(expr.Target)
	if err != nil {
		return "", err
	}

	if len(expr.Indices) == 0 {
		g.reportErrorAtNode(
			"index expression requires at least one index",
			expr,
			diag.CodeGenInvalidIndex,
			"provide at least one index value, e.g., array[0] or map[key]",
		)
		return "", fmt.Errorf("index expression requires at least one index")
	}

	// Get target type
	var targetType types.Type
	if t, ok := g.typeInfo[expr.Target]; ok {
		targetType = t
	} else {
		g.reportErrorAtNode(
			"cannot determine type of indexing target",
			expr,
			diag.CodeGenTypeMappingError,
			"ensure the target expression has a valid type that supports indexing",
		)
		return "", fmt.Errorf("cannot determine type of indexing target")
	}

	// Generate index expression
	indexReg, err := g.genExpr(expr.Indices[0])
	if err != nil {
		return "", err
	}

	resultReg := g.nextReg()

	// Determine element type
	var elemType types.Type
	var isPointer bool

	switch t := targetType.(type) {
	case *types.Array:
		elemType = t.Elem
		isPointer = false
	case *types.Slice:
		elemType = t.Elem
		isPointer = true // Slices are pointers to data
	case *types.GenericInstance:
		// Check if it's a Vec or similar collection type
		if _, ok := t.Base.(*types.Struct); ok {
			// For Vec, we'll need runtime functions
			// For now, treat as pointer
			isPointer = true
			// Try to get element type from type arguments
			if len(t.Args) > 0 {
				elemType = t.Args[0]
			} else {
				elemType = &types.Primitive{Kind: types.Int} // Default
			}
		} else {
			g.reportErrorAtNode(
				fmt.Sprintf("indexing on generic instance type `%T` is not yet fully supported", targetType),
				expr,
				diag.CodeGenUnsupportedExpr,
				"indexing is currently only supported for array, slice, and Vec types",
			)
			return "", fmt.Errorf("indexing on generic instance not yet fully supported")
		}
	default:
		g.reportErrorAtNode(
			fmt.Sprintf("cannot index into type `%T`", targetType),
			expr,
			diag.CodeGenInvalidOperation,
			"indexing is only supported for array, slice, Vec, and map types",
		)
		return "", fmt.Errorf("cannot index into type: %T", targetType)
	}

	elemLLVM, err := g.mapType(elemType)
	if err != nil {
		return "", err
	}

	// Generate getelementptr instruction for indexing
	if isPointer {
		// For slices/pointers: getelementptr inbounds type, type* %ptr, i64 %index
		g.emit(fmt.Sprintf("  %s = getelementptr inbounds %s, %s* %s, i64 %s",
			resultReg, elemLLVM, elemLLVM, targetReg, indexReg))
		// Load the value
		loadReg := g.nextReg()
		g.emit(fmt.Sprintf("  %s = load %s, %s* %s", loadReg, elemLLVM, elemLLVM, resultReg))
		return loadReg, nil
	} else {
		// For arrays: getelementptr inbounds [N x T], [N x T]* %array, i64 0, i64 %index
		arrayLLVM, err := g.mapType(targetType)
		if err != nil {
			return "", err
		}
		g.emit(fmt.Sprintf("  %s = getelementptr inbounds %s, %s* %s, i64 0, i64 %s",
			resultReg, arrayLLVM, arrayLLVM, targetReg, indexReg))
		// Load the value
		loadReg := g.nextReg()
		g.emit(fmt.Sprintf("  %s = load %s, %s* %s", loadReg, elemLLVM, elemLLVM, resultReg))
		return loadReg, nil
	}
}

func (g *LLVMGenerator) genIndexPtr(expr *mast.IndexExpr) (string, error) {
	// Similar to genIndexExpr but returns pointer instead of loaded value
	targetReg, err := g.genExpr(expr.Target)
	if err != nil {
		return "", err
	}

	if len(expr.Indices) == 0 {
		g.reportErrorAtNode(
			"index expression requires at least one index",
			expr,
			diag.CodeGenInvalidIndex,
			"provide at least one index value, e.g., array[0] or map[key]",
		)
		return "", fmt.Errorf("index expression requires at least one index")
	}

	indexReg, err := g.genExpr(expr.Indices[0])
	if err != nil {
		return "", err
	}

	var targetType types.Type
	if t, ok := g.typeInfo[expr.Target]; ok {
		targetType = t
	} else {
		g.reportErrorAtNode(
			"cannot determine type of indexing target",
			expr,
			diag.CodeGenTypeMappingError,
			"ensure the target expression has a valid type that supports indexing",
		)
		return "", fmt.Errorf("cannot determine type of indexing target")
	}

	resultReg := g.nextReg()
	var elemType types.Type
	var isPointer bool

	switch t := targetType.(type) {
	case *types.Array:
		elemType = t.Elem
		isPointer = false
	case *types.Slice:
		elemType = t.Elem
		isPointer = true
	case *types.GenericInstance:
		if _, ok := t.Base.(*types.Struct); ok {
			isPointer = true
			if len(t.Args) > 0 {
				elemType = t.Args[0]
			} else {
				elemType = &types.Primitive{Kind: types.Int}
			}
		} else {
			g.reportErrorAtNode(
				fmt.Sprintf("indexing on generic instance type `%T` is not yet fully supported", targetType),
				expr,
				diag.CodeGenUnsupportedExpr,
				"indexing is currently only supported for array, slice, and Vec types",
			)
			return "", fmt.Errorf("indexing on generic instance not yet fully supported")
		}
	default:
		g.reportErrorAtNode(
			fmt.Sprintf("cannot index into type `%T`", targetType),
			expr,
			diag.CodeGenInvalidOperation,
			"indexing is only supported for array, slice, Vec, and map types",
		)
		return "", fmt.Errorf("cannot index into type: %T", targetType)
	}

	elemLLVM, err := g.mapType(elemType)
	if err != nil {
		return "", err
	}

	if isPointer {
		g.emit(fmt.Sprintf("  %s = getelementptr inbounds %s, %s* %s, i64 %s",
			resultReg, elemLLVM, elemLLVM, targetReg, indexReg))
	} else {
		arrayLLVM, err := g.mapType(targetType)
		if err != nil {
			return "", err
		}
		g.emit(fmt.Sprintf("  %s = getelementptr inbounds %s, %s* %s, i64 0, i64 %s",
			resultReg, arrayLLVM, arrayLLVM, targetReg, indexReg))
	}

	return resultReg, nil
}
